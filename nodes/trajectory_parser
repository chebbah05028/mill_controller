#!/usr/bin/env python

'''
This script contains a ROS node that accepts Trajectory messages and produces a GCode file based on the included trajectory data. Publishes a bool message as a notification to the next node in the pipeline.
This script presumes that the CNC machine has been properly homed and had the G54 workspace set up beforehand. It will not make any safety checks on input coordinates.
For more information on the appropriate format of Trajectory messages, see Trajectory.msg in the msgs directory.
Uses the following parameters:
  m_width
  m_height
  m_angle
  x_offset
  y_offset
'''
'''
TODO
Import ros parameters using rospy.get_param('relative name','default value')
Form a rotation matrix and a translation vector
Form a transformation matrix SE(2)
Peel out x and y data from commands, transform into w_space using T matrix
z coordinates won't change, even when we move to 3d, so re-assemble the command and parse it into Gcode
Add workspace and machine space safety checks?
'''

import rospy
import sys
from std_msgs.msg import Bool
from mill_controller.msg import Trajectory


# Use this publisher to send the output flag
pub = rospy.Publisher('gcode_ready_flag',Bool,queue_size=1)



def callback(message):
    # Upon receiving a Trajectory message, parse the information and write a GCode file based on it.

    # Read parameters from the namespace or use reasonable defaults
    width = rospy.get_param("m_width", 279.4)
    height = rospy.get_param("m_height", 215.9)
    angle = rospy.get_param("m_angle", 0.0)
    x_offset = rospy.get_param("x_offset", 0.0)
    y_offset = rospy.get_param("y_offset", 0.0)

    # TODO: Compose parameter data to produce a T matrix from material to machine

    # TODO: for i in range(message.length)
    #           vector = np.array(3x1, x, y, 1)
    #           vector = T.dot(vector)
    #           message.x[i] = vector[0]
    #           message.y[i] = vector[1]

    # Open output file
    f = open('output.gcode', 'w')

    # Write the Header
    s = ''

    # Basic Settings
    s = s + 'G90' + '\n'                    # Set absolute coordinates
    s = s + 'G21' + '\n'                    # Set mm
    s = s + 'G17' + '\n'                    # Set plane to x/y
    s = s + 'G94' + '\n'                    # Set feed rate to mm/min
    s = s + 'G54' + '\n'                    # Use WCS G54 Coordinates

    f.write(s)                              # Write to file



    # Write the Body
    # Set Feed rate and move to starting point.
    s = 'G0' + ' X' + str(message.x[0]) + ' Y' + str(message.y[0]) + '\n'
    s = s + 'G0' + ' Z-15' + '\n'
    s = s + 'G1' + ' Z-20.0762' + ' F50' + '\n'

    f.write(s)

    # Follow trajectory. Operating on the assumption that the trajectory can be approximated as a series of straight line motions from point to point. Improvement of this model will probably need example trajectories to test. Starting with fixed feed rate.
    for index in range(message.length):
        s = 'G1' + ' X' + str(message.x[index]) + ' Y' + str(message.y[index]) + ' F200.0' + '\n'
        # Write appropriate command to output
        f.write(s)



    # Write the Footer
    s = ''
    s = s + 'G90' + '\n'                    # Set to absolute coordinates
    s = s + 'G21' + '\n'                    # Set to mm
    s = s + 'G17' + '\n'                    # Set plane to x/y
    s = s + 'G94' + '\n'                    # Set feed rate to mm/min
    s = s + 'G54' + '\n'                    # Use WCS G54 Coordinates

    s = s + 'G1 Z-15 F50' + '\n'       # Move bit out of harms way
    s = s + 'G0 Z0' + '\n'
    s = s + 'G0 X450 Y350' + '\n'

    s = s + 'G4 P0.1' + '\n'                # Dwell for a moment
    f.write(s)                              # Write to file


    # Close output
    f.close()

    # Publish to a flag topic to trigger the next node.
    flag = Bool()
    flag.data = True
    pub.publish(flag)




def main():
    # Initialize the ROS node and Subscriber
    rospy.init_node("trajectory_parser_node")
    rospy.Subscriber('trajectory_input',Trajectory,callback)

    # Spin until shut down
    rospy.spin()





if __name__ == '__main__':
    main()
