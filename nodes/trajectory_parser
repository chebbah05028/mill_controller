#!/usr/bin/env python

'''
This script contains a ROS node that accepts Trajectory messages and produces a GCode file based on the included trajectory data. Publishes a bool message as a notification to the next node in the pipeline.
This script presumes that the CNC machine has been properly homed and had the G54 workspace set up beforehand. It will not make any safety checks on input coordinates.
For more information on the appropriate format of Trajectory messages, see Trajectory.msg in the msgs directory.
Uses the following parameters:
  m_width
  m_height
  m_angle
  x_offset
  y_offset
'''

'''
TODO
Add workspace and machine space safety checks?
'''

import numpy as np
import rospy
import sys
from std_msgs.msg import Bool
from mill_controller.msg import Trajectory


# Use this publisher to send the output flag
pub = rospy.Publisher('gcode_ready_flag',Bool,queue_size=1)



def callback(message):
    # Upon receiving a Trajectory message, parse the information and write a GCode file based on it.

    # Make a copy of message so that it can be modified
    msg = Trajectory()

    # Read parameters from the namespace or use reasonable defaults
    width = rospy.get_param("m_width", 279.4)
    height = rospy.get_param("m_height", 215.9)
    theta = rospy.get_param("m_angle", 0.0)
    x_offset = rospy.get_param("x_offset", 0.0)
    y_offset = rospy.get_param("y_offset", 0.0)

    # Compose parameter data to produce a T matrix from material to machine
    Twm = np.zeros((3,3))
    Twm[2,2] = 1.0
    Twm[0,0] = np.cos(np.deg2rad(theta))
    Twm[0,1] = -np.sin(np.deg2rad(theta))
    Twm[0,2] = x_offset
    Twm[1,0] = np.sin(np.deg2rad(theta))
    Twm[1,1] = np.cos(np.deg2rad(theta))
    Twm[1,2] = y_offset
    Twm[2,2] = 1.0

    print type(msg.x)

    # Transform the x and y of the input message into world frame coordinates
    for i in range(message.length):
        vector = np.ones((3,1))
        vector[0,0] = message.x[i]
        vector[1,0] = message.y[i]
        vector = Twm.dot(vector)
        msg.x[i] = vector[0,0]
        msg.y[i] = vector[1,0]
        print (str(msg.x[i])+'\t'+str(msg.y[i]))

    return 0

    # Open output file
    f = open('output.gcode', 'w')

    # Write the Header
    s = ''

    # Basic Settings
    s = s + 'G90' + '\n'                    # Set absolute coordinates
    s = s + 'G21' + '\n'                    # Set mm
    s = s + 'G17' + '\n'                    # Set plane to x/y
    s = s + 'G94' + '\n'                    # Set feed rate to mm/min
    s = s + 'G54' + '\n'                    # Use WCS G54 Coordinates

    f.write(s)                              # Write to file



    # Write the Body
    # Set Feed rate and move to starting point.
    s = 'G0' + ' X' + str(message.x[0]) + ' Y' + str(message.y[0]) + '\n'
    s = s + 'G0' + ' Z-15' + '\n'
    s = s + 'G1' + ' Z-20.0762' + ' F50' + '\n'

    f.write(s)

    # Follow trajectory. Operating on the assumption that the trajectory can be approximated as a series of straight line motions from point to point. Improvement of this model will probably need example trajectories to test. Starting with fixed feed rate.
    for index in range(message.length):
        s = 'G1' + ' X' + str(message.x[index]) + ' Y' + str(message.y[index]) + ' F200.0' + '\n'
        # Write appropriate command to output
        f.write(s)



    # Write the Footer
    s = ''
    s = s + 'G90' + '\n'                    # Set to absolute coordinates
    s = s + 'G21' + '\n'                    # Set to mm
    s = s + 'G17' + '\n'                    # Set plane to x/y
    s = s + 'G94' + '\n'                    # Set feed rate to mm/min
    s = s + 'G54' + '\n'                    # Use WCS G54 Coordinates

    s = s + 'G1 Z-15 F50' + '\n'       # Move bit out of harms way
    s = s + 'G0 Z0' + '\n'
    s = s + 'G0 X450 Y350' + '\n'

    s = s + 'G4 P0.1' + '\n'                # Dwell for a moment
    f.write(s)                              # Write to file


    # Close output
    f.close()

    # Publish to a flag topic to trigger the next node.
    flag = Bool()
    flag.data = True
    pub.publish(flag)




def main():
    # Initialize the ROS node and Subscriber
    rospy.init_node("trajectory_parser_node")
    rospy.Subscriber('trajectory_input',Trajectory,callback)

    # Spin until shut down
    rospy.spin()





if __name__ == '__main__':
    main()
